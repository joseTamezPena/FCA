---
title: "Univariate Options: Parkinsons"
author: "Jose Tamez"
date: "`r Sys.Date()`"
output: 
  html_document: 
    toc: yes
    fig_caption: yes
    number_sections: yes
  word_document: 
    reference_docx: WordStyle_FRESA.docx
    toc: yes
    fig_caption: yes
editor_options:
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(collapse = TRUE, warning = FALSE, message = FALSE,comment = "#>")
```

# Parkinsons Univariate

### Loading the libraries

```{r}
library("FRESA.CAD")
library(readxl)

op <- par(no.readonly = TRUE)
pander::panderOptions('digits', 3)
pander::panderOptions('table.split.table', 400)
pander::panderOptions('keep.trailing.zeros',TRUE)
signedlog <- function(x) { return (sign(x)*(abs(log10(abs(1.0e12*x)+1.0)-12.0)))}


```



## The Data

```{r}

pd_speech_features <- as.data.frame(read_excel("~/GitHub/FCA/Data/pd_speech_features.xlsx",sheet = "pd_speech_features", range = "A2:ACB758"))




```

### The Average of the Three Repetitions

Each subject had three repeated observations. Here I'll use the average of the three experiments per subject.

```{r results = "asis", warning = FALSE, dpi=600, fig.height= 6.0, fig.width= 8.0}
rep1Parkison <- subset(pd_speech_features,RID==1)
rownames(rep1Parkison) <- rep1Parkison$id
rep1Parkison$id <- NULL
rep1Parkison$RID <- NULL
rep1Parkison[,1:ncol(rep1Parkison)] <- sapply(rep1Parkison,as.numeric)

rep2Parkison <- subset(pd_speech_features,RID==2)
rownames(rep2Parkison) <- rep2Parkison$id
rep2Parkison$id <- NULL
rep2Parkison$RID <- NULL
rep2Parkison[,1:ncol(rep2Parkison)] <- sapply(rep2Parkison,as.numeric)

rep3Parkison <- subset(pd_speech_features,RID==3)
rownames(rep3Parkison) <- rep3Parkison$id
rep3Parkison$id <- NULL
rep3Parkison$RID <- NULL
rep3Parkison[,1:ncol(rep3Parkison)] <- sapply(rep3Parkison,as.numeric)

whof <- !(colnames(rep1Parkison) %in% c("gender","class"));
avgParkison <- rep1Parkison;
avgParkison[,whof] <- (rep1Parkison[,whof] + rep2Parkison[,whof] + rep3Parkison[,whof])/3
## I apply the log transform to the data
##avgParkison[,whof] <- signedlog(avgParkison[,whof])
avgParkison[,whof] <- FRESAScale(avgParkison[,whof],method="OrderLogit")$scaledData
pander::pander(table(avgParkison$class))

```

#### Standarize the names for the reporting

```{r results = "asis"}
dataframe <- avgParkison
outcome <- "class"
n_topfeatures <- 5

```



```{r results = "asis"}
pander::pander(c(rows=nrow(dataframe),col=ncol(dataframe)-1))
pander::pander(table(dataframe[,outcome]))

varlist <- colnames(dataframe)
varlist <- varlist[varlist != outcome]
varlist <- as.data.frame(cbind(name=varlist,desc=varlist))

```


```{r results = "asis", warning = FALSE, dpi=600, fig.height= 5.0, fig.width= 7.0}
cormat <- cor(dataframe[,varlist[,1]],method="spearman")
cormat[is.na(cormat)] <- 0
gplots::heatmap.2(abs(cormat),
                  trace = "none",
#                  scale = "row",
                  mar = c(5,5),
                  col=rev(heat.colors(5)),
                  main = "Spearman Correlation Original",
                  cexRow = 0.35,
                  cexCol = 0.35,
                  key.title=NA,
                  key.xlab="Spearman Correlation",
                  xlab="Feature", ylab="Feature")

```



## Decorrelation Analysis

```{r results = "asis"}


DEdataframe <- list();
optionNames <- character();
idx <- 1
DEdataframe[[idx]] <- GDSTMDecorrelation(dataframe,Outcome=outcome,verbose = TRUE)
optionNames <- c(optionNames,"OD_LM_FAST_R")
idx <- idx + 1


DEdataframe[[idx]] <- GDSTMDecorrelation(dataframe,Outcome=outcome,type="LM",method="pearson",verbose = TRUE)
optionNames <- c(optionNames,"OD_LM_Pearson_R")
idx <- idx + 1

DEdataframe[[idx]] <- GDSTMDecorrelation(dataframe,Outcome=outcome,type="LM",method="spearman",verbose = TRUE)
optionNames <- c(optionNames,"OD_LM_Spearman_R")
idx <- idx + 1

DEdataframe[[idx]] <- GDSTMDecorrelation(dataframe,Outcome=outcome,type="RLM",method="pearson",verbose = TRUE)
optionNames <- c(optionNames,"OD_RLM_Pearson_R")
idx <- idx + 1

DEdataframe[[idx]] <- GDSTMDecorrelation(dataframe,Outcome=outcome,type="RLM",method="spearman",verbose = TRUE)
optionNames <- c(optionNames,"OD_RLM_Spearman_R")
idx <- idx + 1

DEdataframe[[idx]] <- GDSTMDecorrelation(dataframe,verbose = TRUE)
optionNames <- c(optionNames,"B_LM_Pearson_R")
idx <- idx + 1

DEdataframe[[idx]] <- GDSTMDecorrelation(dataframe,type="LM",method="spearman",verbose = TRUE)
optionNames <- c(optionNames,"B_LM_Spearman_R")
idx <- idx + 1

DEdataframe[[idx]] <- GDSTMDecorrelation(dataframe,type="RLM",method="pearson",verbose = TRUE)
optionNames <- c(optionNames,"B_RLM_Pearson_R")
idx <- idx + 1

DEdataframe[[idx]] <- GDSTMDecorrelation(dataframe,type="RLM",method="spearman",verbose = TRUE)
optionNames <- c(optionNames,"B_RLM_Spearman_R")
idx <- idx + 1

DEdataframe[[idx]] <- GDSTMDecorrelation(dataframe,Outcome=outcome,skipRelaxed=TRUE,verbose = TRUE)
optionNames <- c(optionNames,"OD_LM_Pearson_NR")
idx <- idx + 1

DEdataframe[[idx]] <- GDSTMDecorrelation(dataframe,Outcome=outcome,type="LM",method="spearman",skipRelaxed=TRUE,verbose = TRUE)
optionNames <- c(optionNames,"OD_LM_Spearman_NR")
idx <- idx + 1

DEdataframe[[idx]] <- GDSTMDecorrelation(dataframe,Outcome=outcome,type="RLM",method="pearson",skipRelaxed=TRUE,verbose = TRUE)
optionNames <- c(optionNames,"OD_RLM_Pearson_NR")
idx <- idx + 1

DEdataframe[[idx]] <- GDSTMDecorrelation(dataframe,Outcome=outcome,type="RLM",method="spearman",skipRelaxed=TRUE,verbose = TRUE)
optionNames <- c(optionNames,"OD_RLM_Spearman_NR")
idx <- idx + 1

DEdataframe[[idx]] <- GDSTMDecorrelation(dataframe,skipRelaxed=TRUE,verbose = TRUE)
optionNames <- c(optionNames,"B_LM_Pearson_NR")
idx <- idx + 1

DEdataframe[[idx]] <- GDSTMDecorrelation(dataframe,type="LM",method="spearman",skipRelaxed=TRUE,verbose = TRUE)
optionNames <- c(optionNames,"B_LM_Spearman_NR")
idx <- idx + 1

DEdataframe[[idx]] <- GDSTMDecorrelation(dataframe,type="RLM",method="pearson",skipRelaxed=TRUE,verbose = TRUE)
optionNames <- c(optionNames,"B_RLM_Pearson_NR")
idx <- idx + 1

DEdataframe[[idx]] <- GDSTMDecorrelation(dataframe,type="RLM",method="spearman",skipRelaxed=TRUE,verbose = TRUE)
optionNames <- c(optionNames,"B_RLM_Spearman_NR")
idx <- idx + 1

names(DEdataframe) <- optionNames

```

### Checking decorrelation properties
```{r results = "asis", warning = FALSE, dpi=600, fig.height= 5.0, fig.width= 7.0}
varlistDe <- list();
Decorrleated_Fraction <- numeric(length(optionNames));
Base_Fraction <- numeric(length(optionNames));
sparse_Fraction <- numeric(length(optionNames));
inum <- 1;
for (demat in optionNames)
{
  Deframe <- DEdataframe[[demat]];
  Decorrleated_Fraction[inum] <- sum(str_detect(colnames(Deframe),"De_"))/(ncol(Deframe)-1)
  Base_Fraction[inum]=sum(str_detect(colnames(Deframe),"Ba_"))/(ncol(Deframe)-1)
  Gdemat <- attr(Deframe,"GDSTM")
  sparse_Fraction[inum]=1.0-sum(Gdemat==0)/ncol(Gdemat)/nrow(Gdemat)
  tvarlist <-  colnames(Deframe)[colnames(Deframe) != "class"];
  varlistDe[[inum]] <- as.data.frame(cbind(name=tvarlist,desc=tvarlist))
  
  cormat <- cor(Deframe[,tvarlist],method="spearman")
  cormat[is.na(cormat)] <- 0
  gplots::heatmap.2(abs(cormat),
                  trace = "none",
#                  scale = "none",
                  mar = c(5,5),
                  col=rev(heat.colors(5)),
                  main = demat,
                  cexRow = 0.35,
                  cexCol = 0.35,
                  key.title=NA,
                  key.xlab="Spearman Correlation",
                  xlab="Feature", ylab="Feature")

  
  

  
 inum = inum + 1; 
}

propDecor <- as.data.frame(cbind(Decorrleated_Fraction,Base_Fraction,sparse_Fraction))
rownames(propDecor) <- optionNames
pander::pander(propDecor)

names(varlistDe) <- optionNames

```


## Univariate

```{r results = "asis", warning = FALSE, dpi=600, fig.height= 5.0, fig.width= 7.0}

Bonthrpvalue <- 0.05/nrow(varlist)/length(optionNames)

univariate_columns <- c("caseMean","caseStd","controlMean","controlStd","cohortKSP","ROCAUC","WilcoxRes.p","FRes.p")

univar <- uniRankVar(varlist,
	           paste(outcome,"~1"),
	           outcome,
	           dataframe,
	           categorizationType = "Raw",
	           type = "LOGIT",
	           rankingTest = "AUC",
	            uniType = "Binary")

topvar <- univar$orderframe$Name[univar$orderframe$WilcoxRes.p < Bonthrpvalue]

#pander::pander(univar$orderframe[1:20,univariate_columns])
#topfiveOrg <- rownames(univar$orderframe[1:5,])

wilpvalues <- univar$orderframe$WilcoxRes.p
names(wilpvalues) <- univar$orderframe$Name

barplot(-log10(wilpvalues),las=2,cex.names=0.3,main="Raw: Wilcoxon p-values",ylab="-log(p)")

AUCvalues <- univar$orderframe$ROCAUC
names(AUCvalues) <- univar$orderframe$Name

barplot(AUCvalues,las=2,cex.names=0.3,main="Raw: ROC AUC",ylab="AUC",col="red")
pander::pander(length(topvar))

```

## Univariate Decorrelated

```{r results = "asis", warning = FALSE, dpi=600, fig.height= 5.0, fig.width= 7.0}
lnum <- 1
univarDe <- list()
for (demat in optionNames)
{

  univarDe[[lnum]] <- uniRankVar(varlistDe[[demat]],
                paste(outcome,"~1"),
  	            outcome,
                DEdataframe[[demat]],
  	            categorizationType = "Raw",
  	            type = "LOGIT",
  	            rankingTest = "AUC",
  	            uniType = "Binary")
  lnum <- lnum + 1 
}
names(univarDe) <- optionNames



```

### ROC AUC of top Features
```{r warning = FALSE, dpi=600, fig.height= 4.0, fig.width= 8.0}
par(op)

toplist <- c(1:n_topfeatures)

#toplist <- names(mRMR.classic_FRESA(dataframe,outcome,n_topfeatures))

par(mfrow=c(1,2))

  topnames <- c(outcome,univar$orderframe[toplist,"Name"])
  topfivelm <- glm(paste(outcome,"~."),dataframe[,topnames],family="binomial")
  print(summary(topfivelm))
  bppred <- predictionStats_binary(cbind(dataframe[,outcome],predict(topfivelm,dataframe)),"RAW",cex=0.80)

  accs <-bppred$accc
  aucs <-bppred$aucs
  bers <-bppred$berror
  

for (demat in optionNames)
{

#  toplist <- names(mRMR.classic_FRESA(DEdataframe[[demat]],outcome,n_topfeatures))

  topnames <- c(outcome,univarDe[[demat]]$orderframe[toplist,"Name"])
  topfivelm <- glm(paste(outcome,"~."),DEdataframe[[demat]][,topnames],family="binomial")
  print(summary(topfivelm))
  bppred <- predictionStats_binary(cbind(DEdataframe[[demat]][,outcome],predict(topfivelm,DEdataframe[[demat]])),demat,cex=0.80)

    aucs <- rbind(aucs,bppred$aucs)
    bers <- rbind(bers,bppred$berror)
    accs <- rbind(accs,bppred$accc)
}

rownames(aucs) <- c("raw",optionNames);
rownames(bers) <- c("raw",optionNames);
rownames(accs) <- c("raw",optionNames);
par(op)
```

### Error plots
```{r results = "asis", warning = FALSE, dpi=600, fig.height= 5.0, fig.width= 7.0}

  bpAUC <- barPlotCiError(as.matrix(aucs),
                          metricname = "ROC AUC: Top",
                          thesets = "AUC",
                          themethod = rownames(aucs),
                          main = "ROC AUC",
                          offsets = c(0.5,1),
                          scoreDirection = ">",
                          ho=0.5,
                          args.legend = list(bg = "white",x="bottomright",inset=c(0.0,0),cex=0.5),
                          col = terrain.colors(nrow(aucs))
                          )

pander::pander(as.data.frame(bpAUC$ciTable))

  bpACC <- barPlotCiError(as.matrix(accs),
                          metricname = "Accuracy: Top",
                          thesets = "Accuracy",
                          themethod = rownames(accs),
                          main = "Accuracy",
                          offsets = c(0.5,1),
                          scoreDirection = ">",
                          ho=0.5,
                          args.legend = list(bg = "white",x="bottomright",inset=c(0.0,0),cex=0.5),
                          col = terrain.colors(nrow(aucs))
                          )
  
  pander::pander(as.data.frame(bpACC$ciTable))

  bpBer <- barPlotCiError(as.matrix(bers),
                          metricname = "BER: Top",
                          thesets = "BER",
                          themethod = rownames(bers),
                          main = "BER",
                          offsets = c(0.5,1),
                          scoreDirection = "<",
                          ho=0.5,
                          args.legend = list(bg = "white",x="topleft",inset=c(0.0,0),cex=0.4),
                          col = terrain.colors(nrow(aucs))
                          )
  
    pander::pander(as.data.frame(bpBer$ciTable))


```

